#version 460 core

layout(std430, binding = 15) readonly buffer Palette {mat4 palette[];};
layout(std430, binding = 16) readonly buffer BoneIndices {uvec4 boneIndices[];};
layout(std430, binding = 17) readonly buffer Weights {vec4 weights[];};
layout(std430, binding = 18) readonly buffer Positions {float inPos[];};
layout(std430, binding = 19) readonly buffer Normals {float inNorm[];};
layout(std430, binding = 20) readonly buffer Tangents {float inTang[];};
layout(location = 25) uniform int numVertices;
layout(location = 26) uniform bool playing;
struct Vertex
{
    vec4 pos; // w == uv.x
    vec4 norm; // x == uv.y
    vec4 tang;
};
layout(std430, binding = 21) writeonly buffer Vertices {Vertex outVertices[];};

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

void main()
{
	uint index = gl_GlobalInvocationID.x;
    if(index < numVertices) 
    {
       vec3 outPos = vec3(inPos[index * 3], inPos[index * 3 + 1], inPos[index * 3 +2]);
       vec3 outNorm = vec3(inNorm[index * 3], inNorm[index * 3 + 1], inNorm[index * 3 + 2]);
       vec4 outTang = vec4(inTang[index * 3], inTang[index * 3 + 1], inTang[index * 3 + 2], inTang[index * 3 + 3]);
       mat4 skinTransform = mat4(1.0f);
       if(playing)
       {
            skinTransform = palette[boneIndices[index][0]]*weights[index][0]+ palette[boneIndices[index][1]]*weights[index][1]+
            palette[boneIndices[index][2]]*weights[index][2]+palette[boneIndices[index][3]]*weights[index][3];
       }
       outVertices[index].pos.xyz = (skinTransform*vec4(outPos,1.0)).xyz;
       outVertices[index].norm.yzw = (skinTransform*vec4(outNorm,0.0)).xyz;
       outVertices[index].tang.w = outTang.w;
       outVertices[index].tang.xyz = (skinTransform*vec4(outTang.xyz,0.0)).xyz;
    }
}