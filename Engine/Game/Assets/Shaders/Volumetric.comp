#version 460 core

#define NUM_STEPS 32

uniform layout(binding = 0, rgba32f) restrict image2D screenImage;

layout(std140, binding = 0) uniform CameraMatrices
{
	mat4 view;
	mat4 proj;
};
layout(binding = 0) uniform sampler2D depthTex;
layout(location = 0) uniform mat4 invView;
layout(location = 1) uniform float baseExtCoeff;

layout(binding = 0) uniform sampler2D depthTexture;
layout(binding = 1) uniform sampler2D noiseTexture;

float GetLinearZ(float inputDepth)
{
	return -proj[3][2] / (proj[2][2] + (inputDepth * 2.0 - 1.0));
}

vec3 GetWorldPos(float depth, vec2 uvs)
{
	float viewZ = GetLinearZ(depth);
	float viewX = (-viewZ * (uvs.x * 2.0 - 1.0)) / proj[0][0];
	float viewY = (-viewZ * (uvs.y * 2.0 - 1.0)) / proj[1][1];
	return (invView * vec4(vec3(viewX, viewY, viewZ), 1.0)).xyz;
}

float noise(vec3 position, float time)
{
	return texture(noiseTexture, uv);
}

float CalculateExtintionCoeff(vec3 currPos)
{
	return baseExtCoeff * noise(currentPos, time) * noiseAmount;
}

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
void main()
{
	const ivec2 texSize = textureSize(screenImage, 0);
	if(gl_GlobalInvocation.x < texSize.x && gl_GlobalInvocation.y < texSize.y)
	{
		const vec2 uv = vec2(gl_GlobalInvocationID.xy) / vec2(texSize);
		vec3 worldPos = GetWorldPos(texture(depthTexture, uv).r, uv);

		vec3 currPos = vec3(invView[3][0], invView[3][1], invView[3][2]);
		rayDir = worldPos - currPos;

		vec3 marchingStep = rayDir / float(NUM_STEPS);
		float stepSize = length(marchingStep);

		float extCoeff = 0.0;
		//vec3 accInScattering = 0.0;
		for(int i = 0; i < NUM_STEPS; ++i)
		{
			extCoeff += CalculateExtintionCoefficient(currPos)*stepSize;
			//vec3 inScattering = CalculateInScattering(currentPos)*stepSize;
			//accInScattering += inScattering*exp(-extCoeff);
			currPos += marchingStep;
		}
		float transmitance = fogIntensity*exp(-extCoeff);
	}
}