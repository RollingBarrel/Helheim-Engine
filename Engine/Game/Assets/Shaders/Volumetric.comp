#version 460 core
#define PI 3.1415926535897932384626433832795
#extension GL_ARB_bindless_texture : require

uniform layout(binding = 0, rgba32f) restrict image2D screenImage;

layout(std140, binding = 1) uniform DirLight
{
	vec3 dirDir;
	vec4 dirCol; //w is the intensity (0-5)
};
struct PointLight
{
	vec4 pos; //w is the radius
	vec4 col;//a is intensity
};
readonly layout(std430, binding = 0) buffer PointLights
{
	uint numPLights;
	PointLight pLights[];
};
layout(binding = 8) uniform isamplerBuffer pointLightList;
struct SpotLight
{
	vec4 pos; //w intensity
	vec4 aimD;//w cos inner angle
	vec4 col; //w cos outer angle
	float radius;
	int shadowIndex;
};
readonly layout(std430, binding = 1) buffer SpotLights
{
	uint numSLights;
	SpotLight sLights[];
};
layout(binding = 11) uniform isamplerBuffer spotLightList;

struct Shadow
{
	mat4 viewProjMatrix;
	sampler2D shadowMap;
	float bias;
};

readonly layout(std430, binding = 4) buffer SpotLightShadows
{
	Shadow shadows[];
};


layout(std140, binding = 0) uniform CameraMatrices
{
	mat4 view;
	mat4 proj;
	mat4 invView;
};
layout(binding = 0) uniform sampler2D depthTex;
layout(binding = 1) uniform sampler2D noiseTexture;

layout(location = 0) uniform float baseExtCoeff;
layout(location = 1) uniform float currTime;
layout(location = 2) uniform float noiseAmount;
layout(location = 3) uniform float fogIntensity;
layout(location = 4) uniform float anisotropy;

layout(location = 5) uniform uint lightListSize;
layout(location = 6) uniform uvec2 numTiles;
layout(location = 7) uniform uvec2 tileSize;

layout(location = 8) uniform float stepSize;

float GetLinearZ(float inputDepth)
{
	return -proj[3][2] / (proj[2][2] + (inputDepth * 2.0 - 1.0));
}

vec3 GetWorldPos(float depth, vec2 uvs)
{
	float viewZ = GetLinearZ(depth);
	float viewX = (-viewZ * (uvs.x * 2.0 - 1.0)) / proj[0][0];
	float viewY = (-viewZ * (uvs.y * 2.0 - 1.0)) / proj[1][1];
	return (invView * vec4(vec3(viewX, viewY, viewZ), 1.0)).xyz;
}

float noise(in vec3 position,in float time)
{
	return texture(noiseTexture, position.xy + vec2(position.z+time)).r * 2.0 - 1.0;
}

float CalculateExtinctionCoeff(in vec3 currPos)
{
	return baseExtCoeff * noise(currPos, currTime) * noiseAmount;
}

float MieScattering(vec3 V, vec3 lDir)
{
	//Henyey-Greenstein Schlick aproximation
	float k = 1.55*anisotropy - 0.55*anisotropy*anisotropy*anisotropy;
	float toSquareTerm = 1+k*dot(V,lDir);
	return (1.0 - k*k) / (4*PI*toSquareTerm*toSquareTerm);
}

vec3 CalculateInScattering(in vec3 currPos, in vec3 cameraPos)
{
	//light * visibility * phase function
	//Irradiance on that point from all lights
	//vec3 Li = lInt * lAtt * lCol.rgb;

	vec3 vDir = normalize(currPos - cameraPos);
	vec3 li = vec3(0.0);

	//diractional light
	li +=  dirCol.rgb * dirCol.w * MieScattering(vDir, dirDir);

	const uvec2 currTile = uvec2(gl_GlobalInvocationID.xy) / tileSize;
	const uint tileIdx = currTile.y * numTiles.x + currTile.x;
	//point lights
	int idx = texelFetch(pointLightList, int(tileIdx * lightListSize)).x;
	for(uint i = 0; i < lightListSize && idx != -1; idx = (texelFetch(pointLightList, int(tileIdx * lightListSize + i))).x)
	{
		PointLight pLight = pLights[idx];
		vec3 mVector = currPos - pLight.pos.xyz;
		float dist = length(mVector);
		vec3 pDir = normalize(mVector);
		float lAtt = pow(max(1 - pow(dist/ pLight.pos.w,4), 0.0),2) / (dist*dist + 1);
		li += pLight.col.rgb * pLight.col.w * lAtt * MieScattering(vDir, pDir);
		++i;
	}

	//spot lights
	idx = texelFetch(spotLightList, int(tileIdx * lightListSize)).x;
	for (int i = 0; i < lightListSize && idx != -1; idx = (texelFetch(spotLightList, int(tileIdx * lightListSize + i))).x)
	{
		SpotLight sLight = sLights[idx];
		//Shadows
		float shadowValue = 1.0;
		if (sLight.shadowIndex >= 0)
		{
			vec4 lightClipSpace = shadows[sLight.shadowIndex].viewProjMatrix * vec4(currPos, 1);
			vec3 lightNDC = lightClipSpace.xyz / lightClipSpace.w;
			lightNDC.xyz = lightNDC.xyz * 0.5 + 0.5;
			float shadowDepth = texture(shadows[sLight.shadowIndex].shadowMap, lightNDC.xy).r + shadows[sLight.shadowIndex].bias;
			float fragmentDepth = lightNDC.z;

			if(!(lightNDC.x >= 0.0 && lightNDC.x <= 1.0f &&
				lightNDC.y >= 0.0 && lightNDC.y <= 1.0f &&
				fragmentDepth < shadowDepth))
				{
					shadowValue = 0.0;
				}
		}

		vec3 mVector = currPos - sLight.pos.xyz;
		vec3 sDir = normalize(mVector);
		vec3 aimDir = normalize(sLight.aimD.xyz);
		float dist = dot(mVector, aimDir);
		float r = sLight.radius;
		float att = pow(max(1 - pow(dist / r, 4), 0), 2) / (dist * dist + 1);
		float c = dot(sDir, aimDir);
		float cInner = sLight.aimD.w;
		float cOuter = sLight.col.w;
		float cAtt = clamp((c - cOuter) / (cInner - cOuter), 0.0, 1.0);
		att *= cAtt;
		li += sLight.col.rgb * sLight.pos.w * att * shadowValue * MieScattering(vDir, sDir);
		++i;
	}

	return li;
}

float sampleIGN(vec2 pixelXY, float frameTime)
{
	pixelXY += (frameTime * 5.588238f );
	return fract(52.9829189f * fract(0.06711056f*float(pixelXY.x) + 0.00583715f*float(pixelXY.y)));
}

bool IntersectLightShapes(in vec3 o, in vec3 rayDir, out float t0, out float t1)
{
	bool ret = false;
	const uvec2 currTile = uvec2(gl_GlobalInvocationID.xy) / tileSize;
	const uint tileIdx = currTile.y * numTiles.x + currTile.x;
	//Point Lights
	//int idx = texelFetch(pointLightList, int(tileIdx * lightListSize)).x;
	//for(uint i = 0; i < lightListSize && idx != -1; idx = (texelFetch(pointLightList, int(tileIdx * lightListSize + i))).x)
	//{
	//	vec4 pLight = pLights[idx].pos;
	//	vec3 L = pLight.xyz - o;
	//	float tca = dot(L, rayDir);
	//	float r2 = pLight.w * pLight.w;
	//	float d2 =  dot(L, L) - tca * tca;
	//	if(d2 > r2)
	//		break;
	//	float thc = sqrt(r2 - d2);
	//	float tmp = tca - thc;
	//	if(tmp < t0)
	//		t0 = tmp;
	//	tmp = tca + thc;
	//	if(tmp > t1)
	//		if(tmp > t0)
	//			t1 = tmp;
	//		else
	//			t0 = tmp;
	//	ret = true;
	//	++i;
	//}

	int idx = texelFetch(spotLightList, int(tileIdx * lightListSize)).x;
	for (int i = 0; i < lightListSize && idx != -1; idx = (texelFetch(spotLightList, int(tileIdx * lightListSize + i))).x)
	{
		SpotLight sLight = sLights[idx];
		float dotDV = dot(rayDir, sLight.aimD.xyz);
		vec3 CO = o - sLight.pos.xyz;
		float dotCOV = dot(CO, sLight.aimD.xyz);
		float a = dotDV * dotDV - sLight.col.w * sLight.col.w;
		float b = 2*( dotDV*dotCOV - dot(rayDir, CO) * sLight.col.w * sLight.col.w );
		float c = dotCOV * dotCOV - dot(CO, CO) * sLight.col.w * sLight.col.w;
		float det = b*b - 4*a*c;
		if(det > 0)
		{
			float detSqrt = sqrt(det);
			float tmp = (-b-sqrt(det)) / (2*a);
			vec3 p = o + tmp*rayDir;
			if(dot(p - sLight.pos.xyz, sLight.aimD.xyz) > 0.0f)
			{
				if(tmp < t0)
					t0 = tmp;
				ret = true;
			}
			tmp = (-b + detSqrt) / (2*a);
			p = o + tmp*rayDir;
			if(dot(p - sLight.pos.xyz, sLight.aimD.xyz) > 0.0f)
			{
				if(tmp > t1)
					if(tmp < t0)
						t0 = tmp;
					else
						t1 = tmp;
				ret = true;
			}
		}
		else if(det == 0)
		{
			float tmp = -b / (2*a);
			vec3 p = o + tmp*rayDir;
			if(dot(p - sLight.pos.xyz, sLight.aimD.xyz) > 0.0f)
			{
				if(tmp < t0)
					t0 = tmp;
				else if(tmp > t1)
					t1 = tmp;
				ret = true;
			}
		}
		++i;
	}
	return ret;
}

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
void main()
{
	const ivec2 texSize = imageSize(screenImage);
	if(gl_GlobalInvocationID.x < texSize.x && gl_GlobalInvocationID.y < texSize.y)
	{
		const vec2 uv = vec2(gl_GlobalInvocationID.xy) / vec2(texSize);
		const vec3 worldPos = GetWorldPos(texture(depthTex, uv).r, uv);

		const vec3 cameraPos = vec3(invView[3][0], invView[3][1], invView[3][2]);
		vec3 rayDir = worldPos - cameraPos;
		float maxDist = length(rayDir);
		rayDir /= maxDist;
		float t0 = maxDist;
		float t1 = 0.0f;
		
		if(IntersectLightShapes(cameraPos, rayDir, t0, t1))
		{
			t0 = max(t0, 0.0);
			t1 = min(t1, maxDist);
		
			float nSteps = ceil(t1 - t0 / stepSize); //Uniform constant de stepSize
			vec3 marchingStep = rayDir*stepSize;
			vec3 currPos = cameraPos + rayDir*t0+marchingStep*sampleIGN(gl_GlobalInvocationID.xy, currTime);
		
			float extCoeff = 0.0;
			vec3 accInScattering = vec3(0.0);
			for(int i = 0; i < nSteps; ++i)
			{
				extCoeff += CalculateExtinctionCoeff(currPos)*stepSize;
				accInScattering += (CalculateInScattering(currPos, cameraPos)*stepSize)*exp(-extCoeff);
				currPos += marchingStep;
			}
			float transmitance = fogIntensity*exp(-extCoeff);
			vec4 pixelCol = imageLoad(screenImage, ivec2(gl_GlobalInvocationID.xy));
			pixelCol = vec4(pixelCol.rgb * (fogIntensity*exp(-extCoeff)) + (accInScattering * fogIntensity), pixelCol.a);
			imageStore(screenImage, ivec2(gl_GlobalInvocationID.xy), vec4(pixelCol));
		}
	}
}