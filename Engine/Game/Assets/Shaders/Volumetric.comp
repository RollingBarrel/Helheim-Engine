#version 460 core
#extension GL_ARB_bindless_texture : require

#define NUM_STEPS 32

uniform layout(binding = 0, rgba32f) restrict image2D screenImage;

layout(std140, binding = 1) uniform DirLight
{
	vec3 dirDir;
	vec4 dirCol; //w is the intensity (0-5)
};
struct PointLight
{
	vec4 pos; //w is the radius
	vec4 col;//a is intensity
};
readonly layout(std430, binding = 0) buffer PointLights
{
	uint numPLights;
	PointLight pLights[];
};
layout(binding = 8) uniform isamplerBuffer pointLightList;
struct SpotLight
{
	vec4 pos; //w intensity
	vec4 aimD;//w cos inner angle
	vec4 col; //w cos outer angle
	float radius;
	int shadowIndex;
};
readonly layout(std430, binding = 1) buffer SpotLights
{
	uint numSLights;
	SpotLight sLights[];
};
layout(binding = 11) uniform isamplerBuffer spotLightList;


layout(std140, binding = 0) uniform CameraMatrices
{
	mat4 view;
	mat4 proj;
	mat4 invView;
};
layout(binding = 0) uniform sampler2D depthTex;
layout(binding = 1) uniform sampler2D noiseTexture;

layout(location = 0) uniform float baseExtCoeff;
layout(location = 1) uniform float currTime;
layout(location = 2) uniform float noiseAmount;
layout(location = 3) uniform float fogIntensity;

float GetLinearZ(float inputDepth)
{
	return -proj[3][2] / (proj[2][2] + (inputDepth * 2.0 - 1.0));
}

vec3 GetWorldPos(float depth, vec2 uvs)
{
	float viewZ = GetLinearZ(depth);
	float viewX = (-viewZ * (uvs.x * 2.0 - 1.0)) / proj[0][0];
	float viewY = (-viewZ * (uvs.y * 2.0 - 1.0)) / proj[1][1];
	return (invView * vec4(vec3(viewX, viewY, viewZ), 1.0)).xyz;
}

float noise(in vec3 position,in float time)
{
	return texture(noiseTexture, position.xy + vec2(position.z+time)).r * 2.0 - 1.0;
}

float CalculateExtinctionCoeff(in vec3 currPos)
{
	return baseExtCoeff * noise(currPos, currTime) * noiseAmount;
}

float CalculateInScattering(in vec3 currPos)
{
	//diractional light

	//point lights
	pointLightList
	int idx = texelFetch(pointLightList, gl_GlobalInvocation.x).x;
	for(int i = 0; i<lightListSize && idx != -1; idx = texelFetch(pointLightList, gl_GlobalInvocation.x).x)
	{
		
		++i;
	}
	//spot lights
	SpotLightList
	//light * visibility * phase function
}

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
void main()
{
	const ivec2 texSize = imageSize(screenImage);
	if(gl_GlobalInvocationID.x < texSize.x && gl_GlobalInvocationID.y < texSize.y)
	{
		const vec2 uv = vec2(gl_GlobalInvocationID.xy) / vec2(texSize);
		const vec3 worldPos = GetWorldPos(texture(depthTex, uv).r, uv);

		vec3 currPos = vec3(invView[3][0], invView[3][1], invView[3][2]);
		const vec3 rayDir = worldPos - currPos;

		const vec3 marchingStep = rayDir / float(NUM_STEPS);
		const float stepSize = length(marchingStep);

		float extCoeff = 0.0;
		vec3 accInScattering = 0.0;
		for(int i = 0; i < NUM_STEPS; ++i)
		{
			extCoeff += CalculateExtinctionCoeff(currPos)*stepSize;
			vec3 inScattering = CalculateInScattering(currentPos)*stepSize;
			accInScattering += inScattering*exp(-extCoeff);
			currPos += marchingStep;
		}
		float transmitance = fogIntensity*exp(-extCoeff);
		vec4 pixelCol = imageLoad(screenImage, ivec2(gl_GlobalInvocationID.xy));
		pixelCol = vec4(pixelCol.rgb * transmitance, pixelCol.a);
		imageStore(screenImage, ivec2(gl_GlobalInvocationID.xy), vec4(pixelCol));
	}
}