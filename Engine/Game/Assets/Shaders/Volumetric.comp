#version 460 core
#define PI 3.1415926535897932384626433832795
#extension GL_ARB_bindless_texture : require

#define NUM_STEPS 32

uniform layout(binding = 0, rgba32f) restrict image2D screenImage;

layout(std140, binding = 1) uniform DirLight
{
	vec3 dirDir;
	vec4 dirCol; //w is the intensity (0-5)
};
struct PointLight
{
	vec4 pos; //w is the radius
	vec4 col;//a is intensity
};
readonly layout(std430, binding = 0) buffer PointLights
{
	uint numPLights;
	PointLight pLights[];
};
layout(binding = 8) uniform isamplerBuffer pointLightList;
struct SpotLight
{
	vec4 pos; //w intensity
	vec4 aimD;//w cos inner angle
	vec4 col; //w cos outer angle
	float radius;
	int shadowIndex;
};
readonly layout(std430, binding = 1) buffer SpotLights
{
	uint numSLights;
	SpotLight sLights[];
};
layout(binding = 11) uniform isamplerBuffer spotLightList;

struct Shadow
{
	mat4 viewProjMatrix;
	sampler2D shadowMap;
	float bias;
};

readonly layout(std430, binding = 4) buffer SpotLightShadows
{
	Shadow shadows[];
};


layout(std140, binding = 0) uniform CameraMatrices
{
	mat4 view;
	mat4 proj;
	mat4 invView;
};
layout(binding = 0) uniform sampler2D depthTex;
layout(binding = 1) uniform sampler2D noiseTexture;

layout(location = 0) uniform float baseExtCoeff;
layout(location = 1) uniform float currTime;
layout(location = 2) uniform float noiseAmount;
layout(location = 3) uniform float fogIntensity;
layout(location = 4) uniform float anisotropy;

layout(location = 5) uniform uint lightListSize;
layout(location = 6) uniform uvec2 numTiles;
layout(location = 7) uniform uvec2 tileSize;

float GetLinearZ(float inputDepth)
{
	return -proj[3][2] / (proj[2][2] + (inputDepth * 2.0 - 1.0));
}

vec3 GetWorldPos(float depth, vec2 uvs)
{
	float viewZ = GetLinearZ(depth);
	float viewX = (-viewZ * (uvs.x * 2.0 - 1.0)) / proj[0][0];
	float viewY = (-viewZ * (uvs.y * 2.0 - 1.0)) / proj[1][1];
	return (invView * vec4(vec3(viewX, viewY, viewZ), 1.0)).xyz;
}

float noise(in vec3 position,in float time)
{
	return texture(noiseTexture, position.xy + vec2(position.z+time)).r * 2.0 - 1.0;
}

float CalculateExtinctionCoeff(in vec3 currPos)
{
	return baseExtCoeff * noise(currPos, currTime) * noiseAmount;
}

float MieScattering(vec3 V, vec3 lDir)
{
	//Henyey-Greenstein Schlick aproximation
	float k = 1.55*anisotropy - 0.55*anisotropy*anisotropy*anisotropy;
	float toSquareTerm = 1+k*dot(-V,lDir);
	return (1.0 - k*k) / (4*PI*toSquareTerm*toSquareTerm);
}

vec3 CalculateInScattering(in vec3 currPos, in vec3 cameraPos)
{
	//light * visibility * phase function
	//Irradiance on that point from all lights
	//vec3 Li = lInt * lAtt * lCol.rgb;

	vec3 vDir = normalize(currPos - cameraPos);
	vec3 li = vec3(0.0);

	//diractional light
	li +=  dirCol.rgb * dirCol.w * MieScattering(vDir, dirDir);

	const uvec2 currTile = uvec2(gl_GlobalInvocationID.xy) / tileSize;
	const uint tileIdx = currTile.y * numTiles.x + currTile.x;
	//point lights
	int idx = texelFetch(pointLightList, int(tileIdx * lightListSize)).x;
	for(uint i = 0; i < lightListSize && idx != -1; idx = (texelFetch(pointLightList, int(tileIdx * lightListSize + i))).x)
	{
		PointLight pLight = pLights[idx];
		vec3 mVector = currPos - pLight.pos.xyz;
		float dist = length(mVector);
		vec3 pDir = normalize(mVector);
		float lAtt = pow(max(1 - pow(dist/ pLight.pos.w,4), 0.0),2) / (dist*dist + 1);
		li += pLight.col.rgb * pLight.col.w * lAtt * MieScattering(vDir, pDir);
		++i;
	}

	//spot lights
	idx = texelFetch(spotLightList, int(tileIdx * lightListSize)).x;
	for (int i = 0; i < lightListSize && idx != -1; idx = (texelFetch(spotLightList, int(tileIdx * lightListSize + i))).x)
	{
		SpotLight sLight = sLights[idx];
		//Shadows
		float shadowValue = 1.0;
		if (sLight.shadowIndex >= 0)
		{
			vec4 lightClipSpace = shadows[sLight.shadowIndex].viewProjMatrix * vec4(currPos, 1);
			vec3 lightNDC = lightClipSpace.xyz / lightClipSpace.w;
			lightNDC.xyz = lightNDC.xyz * 0.5 + 0.5;
			float shadowDepth = texture(shadows[sLight.shadowIndex].shadowMap, lightNDC.xy).r + shadows[sLight.shadowIndex].bias;
			float fragmentDepth = lightNDC.z;

			if(!(lightNDC.x >= 0.0 && lightNDC.x <= 1.0f &&
				lightNDC.y >= 0.0 && lightNDC.y <= 1.0f &&
				fragmentDepth < shadowDepth))
				{
					shadowValue = 0.0;
				}
		}

		vec3 mVector = currPos - sLight.pos.xyz;
		vec3 sDir = normalize(mVector);
		vec3 aimDir = normalize(sLight.aimD.xyz);
		float dist = dot(mVector, aimDir);
		float r = sLight.radius;
		float att = pow(max(1 - pow(dist / r, 4), 0), 2) / (dist * dist + 1);
		float c = dot(sDir, aimDir);
		float cInner = sLight.aimD.w;
		float cOuter = sLight.col.w;
		float cAtt = clamp((c - cOuter) / (cInner - cOuter), 0.0, 1.0);
		att *= cAtt;
		li += sLight.col.rgb * sLight.pos.w * att * shadowValue * MieScattering(vDir, sDir);
		++i;
	}

	return li;
}

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
void main()
{
	const ivec2 texSize = imageSize(screenImage);
	if(gl_GlobalInvocationID.x < texSize.x && gl_GlobalInvocationID.y < texSize.y)
	{
		const vec2 uv = vec2(gl_GlobalInvocationID.xy) / vec2(texSize);
		const vec3 worldPos = GetWorldPos(texture(depthTex, uv).r, uv);

		const vec3 cameraPos = vec3(invView[3][0], invView[3][1], invView[3][2]);
		vec3 currPos = cameraPos;
		const vec3 rayDir = worldPos - currPos;

		const vec3 marchingStep = rayDir / float(NUM_STEPS);
		const float stepSize = length(marchingStep);

		float extCoeff = 0.0;
		vec3 accInScattering = vec3(0.0);
		for(int i = 0; i < NUM_STEPS; ++i)
		{
			extCoeff += CalculateExtinctionCoeff(currPos)*stepSize;
			vec3 inScattering = CalculateInScattering(currPos, cameraPos)*stepSize;
			accInScattering += inScattering*exp(-extCoeff);
			currPos += marchingStep;
		}
		float transmitance = fogIntensity*exp(-extCoeff);
		vec4 pixelCol = imageLoad(screenImage, ivec2(gl_GlobalInvocationID.xy));
		pixelCol = vec4(pixelCol.rgb * transmitance + accInScattering, pixelCol.a);
		imageStore(screenImage, ivec2(gl_GlobalInvocationID.xy), vec4(pixelCol));
	}
}